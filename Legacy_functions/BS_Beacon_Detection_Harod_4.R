# Functions that retrieve detections' data from the server,
# for specified tags and specified sampling times.
# Additional functions plot the retrieved detections' data

require(ggplot2)
require(lubridate)
require(dplyr)
require(RSQLite)
require(gridExtra)
require(tidyr)

#' Generate a data frame of time intervals based on sampling frequency
#'
#' This function generates a data frame containing start and end timestamps for time intervals
#' sampled at a fixed frequency (in seconds) between a start and end time.
#'
#' @param Start_Time_Str Character string, the start datetime in format "%Y-%m-%d %H:%M:%S", UTC assumed.
#' @param End_Time_Str Character string, the end datetime in format "%Y-%m-%d %H:%M:%S", UTC assumed.
#' @param sample_every_min Numeric, sampling frequency in minutes (default is 15).
#'
#' @return A data.frame with columns:
#'   \item{Start}{Start time in numeric (Unix time) format}
#'   \item{End}{End time in numeric (Unix time) format}
#'   \item{posStart}{Start time as POSIXct (UTC)}
#'   \item{posEnd}{End time as POSIXct (UTC)}
#' @export
#'
#' @examples
#' Query_time_df_sampling_freq("2025-01-01 00:00:00", "2025-01-01 00:01:00", sample_every_min = 15)
#'
Query_time_df_sampling_freq <- function(Start_Time_Str, End_Time_Str, sample_every_min = 1) {
  
  # Convert the input datetime strings to numeric (Unix time)
  num_Start_Time <- as.numeric(as.POSIXct(Start_Time_Str, tz = "UTC"))
  num_End_Time   <- as.numeric(as.POSIXct(End_Time_Str, tz = "UTC"))
  
  # Convert the sampling frequency to seconds
  sample_every_sec <- sample_every_min * 60
  
  # Generate the sequence of start times at the requested frequency
  times <- seq(from = num_Start_Time, to = num_End_Time, by = sample_every_sec)
  
  # Create the data frame with start and end of each interval
  Query_time <- data.frame(
    Start = times,
    End   = times + sample_every_sec
  )
  
  # Convert numeric time back to POSIXct for easier interpretation
  Query_time$posStart <- as.POSIXct(Query_time$Start, tz = "UTC", origin = "1970-01-01")
  Query_time$posEnd   <- as.POSIXct(Query_time$End,   tz = "UTC", origin = "1970-01-01")
  
  return(Query_time)
}


#' Generate time intervals for querying based on number of samples per day
#'
#' This function creates a data frame with start and end times for sampling intervals
#' within a specified time range. The number of samples per day and the duration of
#' each sample (in minutes) can be customized.
#'
#' @param Start_Time_Str Character string. Start time in format "%Y-%m-%d %H:%M:%S" (UTC assumed).
#' @param End_Time_Str Character string. End time in format "%Y-%m-%d %H:%M:%S" (UTC assumed).
#' @param sample_timesPerDay Integer. Number of time samples per day (default: 24, i.e., one per hour).
#' @param sample_lengthMinute Integer. Length of each sample interval in minutes (default: 1).
#'
#' @return A data.frame with:
#'   \item{Start}{Start time in numeric (Unix time) format}
#'   \item{End}{End time in numeric (Unix time) format}
#'   \item{posStart}{Start time in POSIXct format (UTC)}
#'   \item{posEnd}{End time in POSIXct format (UTC)}
#'
#' @examples
#' Query_time_df_sample_times("2025-01-01 00:00:00", "2025-01-01 01:00:00", sample_timesPerDay = 4, sample_lengthMinute = 5)
#'
#' @export
#'
Query_time_df_sample_times <- function(Start_Time_Str, End_Time_Str, sample_timesPerDay = 24, sample_lengthMinute = 1) {
  
  # Convert start and end times to numeric format (seconds since 1970-01-01 UTC)
  num_Start_Time <- as.numeric(as.POSIXct(Start_Time_Str, format = "%Y-%m-%d %H:%M:%S", tz = "UTC"))
  num_End_Time   <- as.numeric(as.POSIXct(End_Time_Str, format = "%Y-%m-%d %H:%M:%S", tz = "UTC"))
  
  # Create a sequence of sample start times within the given range
  # sample_timesPerDay determines how many such intervals per day
  times <- seq(from = num_Start_Time, to = num_End_Time, by = 60 * 60 * 24 / sample_timesPerDay)
  
  # Each time interval ends after sample_lengthMinute minutes
  Query_time <- data.frame(
    Start = times,
    End   = times + (sample_lengthMinute * 60)
  )
  
  # Convert numeric times back to POSIXct format for readability
  Query_time$posStart <- as.POSIXct(Query_time$Start, tz = "UTC", origin = "1970-01-01")
  Query_time$posEnd   <- as.POSIXct(Query_time$End,   tz = "UTC", origin = "1970-01-01")
  
  return(Query_time)
}


#' Retrieve detection data from the ATLAS system database
#'
#' This function queries the ATLAS database for raw tag's detection data within specified time intervals
#' for a set of tag IDs (FullTag). Optionally, the query can be limited to a specific base station (BS),
#' and a custom list of fields can be returned.
#'
#' @param Query_Time_df A data.frame with start and end times in numeric Unix time format (milliseconds),
#'        usually generated by a function like `Query_time_df_sample_times`.
#' @param FullTag A vector of numeric or character tag IDs to query for.
#' @param SYS A list containing the database connection parameters: `user`, `password`, `host`, `port`, and `dbname`.
#' @param BS Optional. A specific base station ID to restrict the query to. Default is `NA` (all stations).
#' @param Fields A comma-separated character string of database fields to retrieve. Default is
#'        `'TAG, TIME, BS, RSSI, GAIN, SNR, SAMPLES_CLK'`.
#'
#' @return A data.frame with all detection rows matching the specified criteria and fields.
#'
#' @examples
#' \dontrun{
#' SYS <- list(user="myuser", password="mypassword", host="localhost", port=3306, dbname="ATLAS")
#' time_df <- Query_time_df_sample_times("2025-01-01 00:00:00", "2025-01-01 01:00:00")
#' det_data <- Det_Data_from_ATLAS_server(time_df, FullTag = c(12345, 23456), SYS = SYS)
#' }
#'
#' @export
#'
Det_Data_from_ATLAS_server <- function(Query_Time_df, FullTag, SYS, BS = NA, Fields = 'TAG, TIME, BS, RSSI, GAIN, SNR, SAMPLES_CLK') {
  
  # Establish connection to the ATLAS MySQL database using the SYS connection details
  dbc <- dbConnect(RMySQL::MySQL(),
                   user = SYS$user,
                   password = SYS$password,
                   host = SYS$host,
                   port = SYS$port,
                   dbname = SYS$dbname)
  
  # Number of tag IDs to query for
  Ntag <- length(FullTag)
  
  # Initialize an empty list to store the SQL queries
  Q <- data.frame(query = rep("c", nrow(Query_Time_df) * Ntag))
  
  # Construct the SQL queries for each tag and time interval
  for (j in 1:nrow(Query_Time_df)) {
    for (i in 1:Ntag) {
      
      # If no specific BS is provided, query for all stations
      if (is.na(BS)) {
        Q$query[(j - 1) * Ntag + i] <- paste('select', Fields,
                                             'from DETECTIONS WHERE TAG =', FullTag[i],
                                             'AND TIME >=', Query_Time_df$Start[j] * 1000,
                                             'AND TIME <=', Query_Time_df$End[j] * 1000)
      } else {
        # Restrict the query to a specific base station
        Q$query[(j - 1) * Ntag + i] <- paste('select', Fields,
                                             'from DETECTIONS WHERE TAG =', FullTag[i],
                                             'AND TIME >=', Query_Time_df$Start[j] * 1000,
                                             'AND TIME <=', Query_Time_df$End[j] * 1000,
                                             'AND BS =', BS)
      }
    }
  }
  
  # Run all SQL queries and collect the results into a list
  All_Data <- apply(X = Q, MARGIN = 1, FUN = dbGetQuery, conn = dbc)
  
  # Disconnect from the database
  dbDisconnect(dbc)
  
  # Combine all detection data into a single data.frame
  RawDet0 <- do.call(rbind.data.frame, All_Data)
  
  return(RawDet0)
}


#' Retrieve and optionally slice ATLAS detection data
#'
#' This function retrieves detection data for specific tags from the ATLAS database within a given time range,
#' sampled either by a specified frequency (e.g., every N minutes) or by a fixed number of samples per day.
#' Optionally, the function can slice the data to return only one detection per base station–tag pair per minute.
#'
#' @param SYS A list of database connection parameters (`user`, `password`, `host`, `port`, and `dbname`).
#' @param Start_Time_Str A string specifying the start of the query time range, in the format `"YYYY-MM-DD HH:MM:SS"`.
#' @param End_Time_Str A string specifying the end of the query time range, in the format `"YYYY-MM-DD HH:MM:SS"`.
#' @param query_time_by_frequency Logical. If `TRUE`, generate query time intervals by sampling every `sample_every_min` minutes.
#'                                If `FALSE`, generate query time intervals based on `sample_timesPerDay` and `sample_lengthMinute`.
#'                                Default is `TRUE`.
#' @param sample_timesPerDay Integer. Number of samples per day if `query_time_by_frequency` is `FALSE`. Default is 24.
#' @param sample_lengthMinute Integer. Length in minutes of each sample window if `query_time_by_frequency` is `FALSE`. Default is 1.
#' @param sample_every_min Integer. Sampling interval in minutes if `query_time_by_frequency` is `TRUE`. Default is 15.
#' @param FullTag A vector of tag IDs to query.
#' @param BS Optional. A specific base station ID to restrict the query to. Default is `NA` (all base stations).
#' @param slice Logical. If `TRUE`, returns only the first detection per base station–tag pair per minute. Default is `TRUE`.
#' @param Fields A character string specifying which fields to retrieve from the database. Default is `'TAG,TIME,BS,RSSI,GAIN,SNR,SAMPLES_CLK'`.
#' @param stringSub A prefix string to remove from the TAG and BS columns. Default is `'9720060'`.
#'
#' @return A data.frame containing detection data from the ATLAS system, optionally sliced.
#'
#' @examples
#' \dontrun{
#' SYS <- list(user="myuser", password="mypassword", host="localhost", port=3306, dbname="ATLAS")
#' # Query with frequency sampling every 10 minutes:
#' Get_ATLAS_Det_DATA(SYS, "2025-01-01 00:00:00", "2025-01-01 06:00:00",
#'                    query_time_by_frequency = TRUE,
#'                    sample_every_min = 10,
#'                    FullTag = c(101, 102))
#' # Query with fixed samples per day:
#' Get_ATLAS_Det_DATA(SYS, "2025-01-01 00:00:00", "2025-01-01 06:00:00",
#'                    query_time_by_frequency = FALSE,
#'                    sample_timesPerDay = 48,
#'                    sample_lengthMinute = 1,
#'                    FullTag = c(101, 102))
#' }
#'
#' @export
Get_ATLAS_Det_DATA <- function(SYS,
                               Start_Time_Str,
                               End_Time_Str,
                               query_time_by_frequency = TRUE,
                               sample_timesPerDay = 24,
                               sample_lengthMinute = 1,
                               sample_every_min = 15,
                               FullTag,
                               BS = NA,
                               slice = TRUE,
                               Fields = 'TAG,TIME,BS,RSSI,GAIN,SNR,SAMPLES_CLK',
                               stringSub = '9720060') {
  
  # Record the start time to measure performance
  STime <- Sys.time()
  
  if (query_time_by_frequency) {
    
    # Generate the query time frame based on time frequency (sample every #minutes)
    Query_Time <- Query_time_df_sampling_freq(Start_Time_Str, 
                                              End_Time_Str, 
                                              sample_every_min)
    
  } else {
    
    # Generate the query time frame based on number of samples per day and sample length
    Query_Time <- Query_time_df(Start_Time_Str, 
                                End_Time_Str, 
                                sample_timesPerDay, 
                                sample_lengthMinute)
    
  }
  
  # Fetch raw detection data from the ATLAS database
  RawDet0 <- Det_Data_from_ATLAS_server(Query_Time, FullTag, SYS, BS, Fields = Fields)
  
  # Remove the system prefix from base station and tag IDs
  RawDet0$BS <- gsub(stringSub, '', RawDet0$BS)
  RawDet0$TAG <- gsub(paste0(stringSub, '00'), '', RawDet0$TAG)
  
  # Convert TIME (milliseconds since epoch) to POSIXct datetime
  RawDet0$dateTime <- as.POSIXct((RawDet0$TIME) / 1000, tz = "UTC", origin = "1970-01-01")
  
  # Optional slicing to get only one record per minute per tag-base pair
  if (slice) {
    RawDet1 <- RawDet0 %>%
      mutate(M = minute(dateTime),
             H = hour(dateTime),
             D = date(dateTime)) %>%
      group_by(TAG, BS) %>%
      mutate(Tag_BS = factor(paste(BS, "-", TAG))) %>%
      add_count() %>%
      ungroup() %>%
      group_by(M, H, D, TAG, BS) %>%
      slice_head() %>%
      ungroup()
  } else {
    RawDet1 <- RawDet0
  }
  
  # Report the processing time
  print('The time to download and reshape data was:')
  print(Sys.time() - STime)
  
  return(RawDet1)
}


# Functions that plot the detections' data
plotCountDet <- function(RawDet1,xAxisRes='3 hours')
      {start_time <- RawDet1$dateTime[1]
RawDet1 %>% ggplot(aes(dateTime, factor(paste(BS,"-",TAG ))))+
   geom_point(aes(x=dateTime,y= factor(paste(BS,"-",TAG )),group=TAG, color=TAG) )+
   # geom_line(aes(x=dateTime,y=BS,group=TAG, color=TAG) ) +
   geom_text(data=RawDet1 %>% distinct(Tag_BS,.keep_all = TRUE) %>% dplyr::select(Tag_BS,n),
             aes(x=start_time, y=Tag_BS, label = n, hjust = +1.1))+
   scale_x_datetime(date_breaks = xAxisRes)+
   theme(axis.text.x=element_text(angle=60, hjust=1)) +
   labs(title= paste(' Beacons detection by Base station'),
        subtitle = paste('period= ',RawDet1$dateTime[1],' - ',max(RawDet1$dateTime)),
        x = "", 
        y = "Base Stations- Beacons")}


plotBSperformance <- function(RawDet1,BS2plot,TAG2plot=NA ,xAxisRes='12 hours')
      {
   if(is.na(TAG2plot))
   {TAG2plot <- unique(RawDet1$TAG)}
   
   p1 <- RawDet1 %>% filter(BS %in% BS2plot ) %>% filter(TAG %in% TAG2plot ) %>%
      ggplot(aes(dateTime, RSSI))+
      geom_point(aes(x=dateTime,y= RSSI,group=interaction(TAG,BS), color=interaction(TAG,BS),shape =BS) )+
      geom_line(aes(x=dateTime,y= RSSI,group=interaction(TAG,BS), color=interaction(TAG,BS)) ) +
      scale_x_datetime(date_breaks = xAxisRes)+
      theme(axis.text.x=element_blank(),
            legend.position=c(0.97, 0.5),
            legend.background = element_rect(color="black",fill ="grey",#transparent",
                                             size=0.5, linetype="solid")) +
      labs(color="TAG.BS",
           # title= paste(' RSSI'),
           title = paste('period= ',RawDet1$dateTime[1],' - ',max(RawDet1$dateTime)),
           x = "", 
           y = "RSSI")
   p2 <- RawDet1 %>% filter(BS %in% BS2plot ) %>% filter(TAG %in% TAG2plot ) %>%
      ggplot(aes(dateTime, SNR))+
      geom_point(aes(x=dateTime,y= SNR,group=interaction(TAG,BS), color=interaction(TAG,BS),shape =BS) )+
      geom_line(aes(x=dateTime,y= SNR,group=interaction(TAG,BS), color=interaction(TAG,BS)) ) +
      scale_x_datetime(date_breaks = xAxisRes)+
      theme(axis.text.x=element_blank(),
            legend.position='none') +
      labs(
           # title= paste(' SNR'),
           # subtitle = paste('period= ',RawDet1$dateTime[1],' - ',max(RawDet1$dateTime)),
           x = "", 
           y = "SNR")
   p3 <- RawDet1 %>% filter(BS %in% BS2plot )  %>%
      ggplot(aes(dateTime, GAIN))+
      geom_point(aes(x=dateTime,y= GAIN,group=BS, color=BS) )+
      geom_line(aes(x=dateTime,y= GAIN,group=BS, color=BS) ) +
      scale_x_datetime(date_breaks = xAxisRes)+
      theme(axis.text.x=element_text(angle=60, hjust=1),
            legend.position=c(0.97, 0.4),
            legend.background = element_rect(color="black",fill ="grey",
                                             size=0.5, linetype="solid")) +
      labs(
           # title= paste(' GAIN'),
           # subtitle = paste('period= ',RawDet1$dateTime[1],' - ',max(RawDet1$dateTime)),
           x = "", 
           y = "GAIN")
   grid.arrange(p1,p2,p3, nrow = 3)
   
}


plotTagsCount <- function (RawDet1,xAxisRes='3 hours',BS2plot=NA) #(RawDet1,BS2plot,TAG2plot=NA ,xAxisRes='12 hours')
      {
   A <- RawDet1 %>% 
      group_by(H,M,D,BS) %>%
      summarise(uniqueTagsDetected=length(unique(TAG)),dateTime=min(dateTime),
                meanSNR=mean(SNR),meanRSSI=mean(RSSI)) %>%
      arrange(dateTime) %>% 
      ungroup()
   if(any(!is.na(BS2plot)))
      A <- A %>% filter(BS %in% BS2plot)
   
   p1 <-   A %>% ggplot(aes(dateTime, uniqueTagsDetected))+
      geom_point(aes(x=dateTime,y= uniqueTagsDetected,group=BS, color=BS) )+
      geom_line(aes(x=dateTime,y= uniqueTagsDetected,group=BS, color=BS) )+
      scale_x_datetime(date_breaks = xAxisRes)+
      theme(axis.text.x=element_text(angle=60, hjust=1)) +
      theme(axis.text.x=element_blank()) +
      labs(title= paste('number unique Tags '),
           subtitle = paste('period= ',RawDet1$dateTime[1],' - ',max(RawDet1$dateTime)),
           x = "", 
           y = "number of unique tags")
   
   p2   <-   A %>% ggplot(aes(dateTime, meanSNR))+
      geom_point(aes(x=dateTime,y= meanSNR,group=BS, color=BS) )+
      geom_line(aes(x=dateTime,y= meanSNR,group=BS, color=BS) )+
      scale_x_datetime(date_breaks = xAxisRes)+
      theme(axis.text.x=element_text(angle=60, hjust=1)) +
      labs(title= paste('mean SNR of detections'),
           subtitle = paste('period= ',RawDet1$dateTime[1],' - ',max(RawDet1$dateTime)),
           x = "", 
           y = "mean SNR")
   grid.arrange(p1,p2, nrow =2)
   print('total detection per BS:')
   print(table(RawDet1$BS))
   
}


plotDriftCases <- function(RawDet2,xAxisRes= '3 hours',BS2plot=NA)
      {
   A <-  RawDet2 %>% group_by(TAG,BS) %>% 
      arrange(TIME) %>% 
      mutate(TimeDiff=SAMPLES_CLK-lag(SAMPLES_CLK)) %>% 
      ungroup()%>% 
      filter(TimeDiff>8e6/2&TimeDiff<8e6*1.5)
   
     A <- A %>% pivot_wider(id_cols= c('TAG','TIME','dateTime'),names_from = BS, values_from = TimeDiff,names_prefix='Diff') %>% 
             mutate(meanDiff=rowMeans(select(.,starts_with('Diff')),na.rm=T),
             N=rowSums(select(.,starts_with('Diff')),na.rm=T)/meanDiff) %>% 
             rowwise() %>% 
             mutate(medDiff = median(c_across(starts_with("Diff")), na.rm = TRUE)) 

   A <- A %>% pivot_longer(
      cols = starts_with("Diff"),
      names_to = "BS",
      names_prefix = "Diff",
      values_to='sampDiff',
      values_drop_na=T
   ) 
   A$samp_div <- abs(A$medDiff-A$sampDiff)
   A <- A %>% filter(samp_div>10 | N<2)
   
   if(any(!is.na(BS2plot)))
      A <- A %>% filter(BS %in% BS2plot)
   
   D <- as.data.frame(table(A$BS,date(A$dateTime)))
   colnames(D) <- c('BS','Date','Count')
   D <- D %>% filter(Count>10)
   
   start_time <- A$dateTime[1]
   p1 <- A %>%  filter(samp_div>10) %>%
      ggplot(aes(dateTime, samp_div))+
      geom_point(aes(x=dateTime,y= samp_div,group=BS, color=BS) )+
      # geom_line(aes(x=dateTime,y= samp_div,group=BS, color=BS) ) +
      scale_x_datetime(date_breaks = xAxisRes)+
      theme(axis.text.x=element_text(angle=60, hjust=1),
            legend.position=c(0.97, 0.5),
            legend.background = element_rect(color="black",fill ="grey",#transparent",
                                             size=0.5, linetype="solid")) +
      labs(title= paste('Beacon detection Base station Sample clock drift '),
           subtitle = paste('period= ',RawDet2$dateTime[1],' - ',max(RawDet2$dateTime)),
           x = "", 
           y = "sample clock drift")

   
   p2 <- A %>% filter(N<2 ) %>%mutate(Tag_BS=paste(BS,"-",TAG ), ) %>% 
      group_by(Tag_BS) %>% mutate(count_TAG_BS=n()) %>% ungroup() %>% 
      ggplot(aes(dateTime, factor(paste(BS,"-",TAG ))))+
      geom_point(aes(x=dateTime,y= factor(paste(BS,"-",TAG )),group=TAG, color=TAG) )+
      # geom_line(aes(x=dateTime,y= factor(paste(BS,"-",TAG )),group=TAG, color=TAG)) +
      geom_text(aes(x=start_time, y=Tag_BS, label = count_TAG_BS, hjust = +1.1))+
      scale_x_datetime(date_breaks = xAxisRes)+
      theme(axis.text.x=element_text(angle=60, hjust=1)) +
      labs(title= paste('unsynced detections (alone in its milisecond), might not be a problem'),
           subtitle = paste('period= ',RawDet2$dateTime[1],' - ',max(RawDet2$dateTime)),
           x = "", 
           y = "Base Stations- Beacons")
   
   grid.arrange(p1,p2, nrow = 2)
   print("sync issues(alone in milisecond or wrong sampleclock difference) per day per BS:")
   return(D)
   
}


# ==========================
# Example usage of functions
# ==========================

# Define time window and sampling parameters
# ------------------------------------------
# Start_Time_Str      <- '2025-03-01 00:00:00'
# End_Time_Str        <- '2025-06-04 16:00:00'
# sample_timesPerDay  <- 24   # hourly samples
# sample_lengthMinute <- 1    # each sample lasts 1 minute

# Define tags to retrieve (short list)
# ------------------------------------
# FullTag <- c(972006000003, 972006000004, 972006000006, 972006000007, 972006000008)

# Retrieve detection data (sliced)
# --------------------------------
# Note: connParms must be defined with the correct DB connection details
# Example: connParms <- list(user="...", password="...", host="...", port=..., dbname="...")
# RawDet1 <- Get_ATLAS_Det_DATA(connParms, Start_Time_Str, End_Time_Str,
#                                sample_timesPerDay, sample_lengthMinute, FullTag)

# Plot detection count per base station over time
# ------------------------------------------------
# plotCountDet(RawDet1, xAxisRes = '12 hour')

# Plot base station performance for selected tags
# ------------------------------------------------
# plotBSperformance(RawDet1,
#                   BS2plot = c("01"),
#                   TAG2plot = c("003", "004", "006", "007", "008"),
#                   xAxisRes = '12 hours')

# Retrieve unsliced data to analyze drift cases
# ---------------------------------------------
# RawDet2 <- Get_ATLAS_Det_DATA(connParms, Start_Time_Str, End_Time_Str,
#                                sample_timesPerDay, sample_lengthMinute,
#                                FullTag, slice = FALSE,
#                                Fields = 'TAG,TIME,BS,SAMPLES_CLK')

# Plot possible drift cases for selected base stations
# -----------------------------------------------------
# plotDriftCases(RawDet2, xAxisRes = '12 hours',
#                BS2plot = c("01", "03", "09", "11", "15", "16"))

# Retrieve data for a larger tag range to evaluate detection counts
# -----------------------------------------------------------------
# FullTag2 <- seq(from = 972006000008, to = 972006001600, by = 1)
# RawDet3 <- Get_ATLAS_Det_DATA(connParms, Start_Time_Str, End_Time_Str,
#                                sample_timesPerDay, sample_lengthMinute, FullTag2)

# Plot detection counts for selected base stations
# -------------------------------------------------
# plotTagsCount(RawDet3, xAxisRes = '24 hours', BS2plot = c("24"))